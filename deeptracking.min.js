if(!window.adobeDataLayer){console.log("Initializing Adobe Data Layer"),window.adobeDataLayer=[],window.adobeDataLayer._listeners=[];const e=window.adobeDataLayer.push;window.adobeDataLayer.push=function(...t){const n=e.apply(this,t);return t.forEach(e=>{if("function"==typeof e)try{e(window.adobeDataLayer)}catch(e){}else"object"==typeof e&&null!==e&&e.event&&window.adobeDataLayer._listeners.forEach(t=>{try{t(e)}catch(e){}})}),n},window.adobeDataLayer.addEventListener=function(e,t){"adobeDataLayer:event"===e&&window.adobeDataLayer._listeners.push(t)}}function init(){Cookiebot.consent.statistics&&(console.log("Cookiebot consent statistics is true, initializing recommendation flow"),initRecommendWorker(),setTimeout(()=>{pushPageViewEvent()},100),attachScrollListener(),attachTimeSpentListeners(),initializeRealTimeRecommendationsWorker())}function getApiEndpoint(){return"https://dovelike-calcinable-catharine.ngrok-free.dev/ingest_event"}const API_ENDPOINT=getApiEndpoint();let pageLoadTime=Date.now(),timeSpentSent=!1,timeSpentInterval=null;function pushToCustomEndpoint(e){const t=window.location.href,n=getSessionId();let r;if("add_to_cart"===e.event||"add_to_cart_recom"===e.event)r={...e,event_type:e.event,user_id:e.userId||e.user_id,product_url:e.product_url||t,item_id:e.item_id||hashString(e.product_url||t),session_id:e.session_id||n,timestamp:(new Date).toISOString()};else{const o=hashString(t);r={...e,event_type:e.event,user_id:e.userId||e.user_id,from_url:t,item_id:o,session_id:e.session_id||n,timestamp:(new Date).toISOString(),component:e.component||void 0}}fetch(API_ENDPOINT,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(r),keepalive:!0}).then(e=>e.ok?e.json().then(e=>e):(console.error("API response not OK:",e.status,e.statusText),e.text().then(e=>(console.error("API error response:",e),e)))).catch(e=>{console.error("Error calling ingest_event API:",e)})}function getTimeSpent(){return Math.round((Date.now()-pageLoadTime)/1e3)}function pushTimeSpentEvent(e="navigation",t=!1){if(!t&&timeSpentSent)return;const n=getTimeSpent();if("navigation"!==e&&"close"!==e)return;const r=window.location.href,o=hashString(r),s=getSessionId(),i={event:"time_spent",userId:getUserId(),session_id:s,page:{url:window.location.href,title:document.title,timeSpentSeconds:n,reason:e},from_url:r,item_id:o};if(t||(timeSpentSent=!0),("navigation"===e||"close"===e)&&navigator.sendBeacon){const e={...i,event_type:"time_spent",user_id:i.userId||i.user_id,timestamp:(new Date).toISOString()},t=new Blob([JSON.stringify(e)],{type:"application/json"});if(navigator.sendBeacon(API_ENDPOINT,t))return}window.adobeDataLayer.push(i)}function storePageVisit(e){try{const t="user_page_visits",n=getStoredPageVisits();n.push(e),sessionStorage.setItem(t,JSON.stringify(n))}catch(e){}}function getStoredPageVisits(){try{const e="user_page_visits",t=sessionStorage.getItem(e);if(t){const e=JSON.parse(t);if(Array.isArray(e))return e;if("string"==typeof e)return e.split(",").filter(Boolean)}return[]}catch(e){try{const e=sessionStorage.getItem(STORAGE_KEY);if(e&&!e.startsWith("[")){const t=e.split(",").filter(Boolean);return sessionStorage.setItem(STORAGE_KEY,JSON.stringify(t)),t}}catch(e){}return[]}}function getStoredRecommendations(){try{const e="recommendation_response",t=localStorage.getItem(e);return t?JSON.parse(t):null}catch(e){return null}}function clearStoredRecommendations(){try{const e="recommendation_response";localStorage.removeItem(e)}catch(e){}}let recommendWorker=null,workerBlobUrl=null;function initRecommendWorker(){try{if("undefined"!=typeof Worker){const e=`\n          const RECOMMEND_API_URL = 'https://nonevil-hilary-lazulitic.ngrok-free.dev/recommend';\n          const BASE_URL = '${window.location.origin}';\n  \n          async function callRecommendAPI(data) {\n            try {\n              const response = await fetch(RECOMMEND_API_URL, {\n                method: 'POST',\n                headers: {\n                  'Content-Type': 'application/json',\n                  Accept: 'application/json',\n                },\n                body: JSON.stringify(data),\n              });\n  \n              if (!response.ok) {\n                throw new Error(\`HTTP error! status: \${response.status}\`);\n              }\n  \n              const result = await response.json();\n              return { success: true, data: result };\n            } catch (error) {\n              return { success: false, error: error.message };\n            }\n          }\n  \n          /**\n           * Extracts path from URL (removes domain)\n           * @param {string} url - Full URL or path\n           * @returns {string} Path without domain\n           */\n          function extractPathFromUrl(url) {\n            if (!url) return '';\n            try {\n              // If it's already a path (starts with /), return as is\n              if (url.startsWith('/')) {\n                return url;\n              }\n              // If it's a full URL, extract the pathname\n              const urlObj = new URL(url);\n              return urlObj.pathname;\n            } catch (e) {\n              // If URL parsing fails, try to extract path manually\n              const match = url.match(/^https?:\\/\\/[^\\/]+(\\/.*)$/);\n              return match ? match[1] : url;\n            }\n          }\n  \n          /**\n           * Fetches query-index.json and matches with recommend API response\n           * @param {Array} recommendItems - Items from recommend API response\n           * @returns {Array} Matching objects from query-index.json\n           */\n          function fetchAndMatchQueryIndex(recommendItems) {\n            // Return a promise chain to ensure proper sequencing after recommend API\n            return new Promise((resolve, reject) => {\n              try {\n                // Construct absolute URL for query-index.json using BASE_URL from main thread\n                const queryIndexUrl = \`\${BASE_URL}/query-index.json\`;\n                \n                // Fetch query-index.json with error handling using promise chain\n                fetch(queryIndexUrl)\n                  .then(queryIndexResponse => {\n                    if (!queryIndexResponse.ok) {\n                      throw new Error(\`Failed to fetch query-index.json: \${queryIndexResponse.status} \${queryIndexResponse.statusText}\`);\n                    }\n                    return queryIndexResponse.json();\n                  })\n                  .then(queryIndexData => {\n                    // Handle different response structures\n                    // query-index.json might be: array, {data: array}, {items: array}, or single object\n                    let queryIndexArray = [];\n                    if (Array.isArray(queryIndexData)) {\n                      queryIndexArray = queryIndexData;\n                    } else if (queryIndexData && typeof queryIndexData === 'object') {\n                      // Try common nested structures\n                      if (Array.isArray(queryIndexData.data)) {\n                        queryIndexArray = queryIndexData.data;\n                      } else if (Array.isArray(queryIndexData.items)) {\n                        queryIndexArray = queryIndexData.items;\n                      } else if (queryIndexData.path) {\n                        // Single object, wrap in array\n                        queryIndexArray = [queryIndexData];\n                      } else {\n                        // Try to extract array from any property\n                        const arrayProps = Object.values(queryIndexData).filter(v => Array.isArray(v));\n                        if (arrayProps.length > 0) {\n                          queryIndexArray = arrayProps[0];\n                        }\n                      }\n                    }\n              \n                    // Extract paths from recommend items\n                    // Recommend API returns: {item_url: "https://...", ...}\n                    const recommendPaths = recommendItems\n                      .map(item => {\n                        const itemUrl = item.item_url || item.url || '';\n                        return extractPathFromUrl(itemUrl);\n                      })\n                      .filter(path => path); // Remove empty paths\n                    \n                    // Match paths and collect matching objects\n                    const matchedItems = queryIndexArray.filter(item => {\n                      const itemPath = item.path || '';\n                      return recommendPaths.some(recommendPath => {\n                        // Normalize paths for comparison (remove trailing slashes)\n                        const normalizedItemPath = itemPath.replace(/\\/$/, '');\n                        const normalizedRecommendPath = recommendPath.replace(/\\/$/, '');\n                        return normalizedItemPath === normalizedRecommendPath;\n                      });\n                    });\n                    \n                    resolve(matchedItems);\n                  })\n                  .catch(error => {\n                    reject(error);\n                  });\n              } catch (error) {\n                reject(error);\n              }\n            });\n          }\n  \n          self.addEventListener('message', async (event) => {\n            const { type, payload } = event.data;\n  \n            if (type === 'recommend') {\n              const originalUserId = payload.original_user_id;\n              const userSequenceOriginal = payload.user_sequence_original;\n              const topK = payload.top_k;\n  \n              if (!originalUserId) {\n                self.postMessage({\n                  type: 'error',\n                  message: 'original_user_id is required',\n                });\n                return;\n              }\n  \n              // Ensure user_sequence_original is an array\n              const sequenceArray = Array.isArray(userSequenceOriginal) \n                ? userSequenceOriginal \n                : (userSequenceOriginal ? [userSequenceOriginal] : []);\n  \n              const requestBody = {\n                original_user_id: originalUserId,\n                user_sequence_original: sequenceArray, // Send as array\n                top_k: topK || 10,\n              };\n  \n              const result = await callRecommendAPI(requestBody);\n  \n              // If recommend API was successful, fetch and match query-index.json\n              if (result.success && result.data) {\n                // Extract items from recommend response\n                // Handle different possible response structures\n                const recommendItems = Array.isArray(result.data) \n                  ? result.data \n                  : (result.data.items || result.data.recommendations || []);\n                \n                if (recommendItems.length > 0) {\n                  // Fetch query-index.json and match paths using promise chain\n                  fetchAndMatchQueryIndex(recommendItems)\n                    .then(matchedItems => {\n                      // Store matched items in sessionStorage\n                      // Note: sessionStorage is not directly accessible in worker\n                      // We'll send it to main thread to store\n                      self.postMessage({\n                        type: 'query_index_matched',\n                        matchedItems: matchedItems,\n                      });\n                    })\n                    .catch(error => {\n                      self.postMessage({\n                        type: 'query_index_error',\n                        error: error.message,\n                      });\n                    });\n                }\n              }\n  \n              // Send recommend response AFTER query-index processing completes\n              // This ensures proper promise chain sequencing\n              self.postMessage({\n                type: 'recommend_response',\n                success: result.success,\n                data: result.data,\n                error: result.error,\n              });\n            }\n          });\n  \n          self.addEventListener('error', (error) => {\n            self.postMessage({\n              type: 'error',\n              message: error.message,\n            });\n          });\n        `,t=new Blob([e],{type:"application/javascript"});workerBlobUrl=URL.createObjectURL(t),recommendWorker=new Worker(workerBlobUrl),recommendWorker.onmessage=e=>{const{type:t,success:n,data:r,error:o,message:s,matchedItems:i}=e.data;if("recommend_response"===t){if(n){try{const e="recommendation_response";localStorage.setItem(e,JSON.stringify({data:r,timestamp:Date.now()}))}catch(e){}window.dispatchEvent(new CustomEvent("recommendationReceived",{detail:{recommendations:r}}))}}else if("query_index_matched"===t){try{const e="query_index_matched_items";sessionStorage.setItem(e,JSON.stringify({items:i,timestamp:Date.now()}))}catch(e){}window.dispatchEvent(new CustomEvent("queryIndexMatched",{detail:{matchedItems:i}}))}},recommendWorker.onerror=()=>{}}}catch(e){}}function requestRecommendations(){try{if(!recommendWorker)return void console.warn("Recommendation worker not initialized");const e=getUserId(),t={original_user_id:e,user_sequence_original:getStoredPageVisits(),top_k:10};recommendWorker.postMessage({type:"recommend",payload:t})}catch(e){console.error("Error requesting recommendations:",e)}}function pushPageViewEvent(){pageLoadTime=Date.now(),timeSpentSent=!1,timeSpentInterval&&(clearInterval(timeSpentInterval),timeSpentInterval=null);const e=getCategoryId(),t=getSessionId(),n=window.location.href,r=hashString(n);storePageVisit(r);const o={event:"page_view",userId:getUserId(),session_id:t,page:{url:window.location.href,title:document.title},category_id:e,from_url:n,item_id:r};window.adobeDataLayer.push(o),requestRecommendations()}function throttle(e,t){let n;return function(...r){clearTimeout(n),n=setTimeout(()=>{clearTimeout(n),e(...r)},t)}}function getScrollPercentage(){const e=window.innerHeight,t=document.documentElement.scrollHeight,n=window.pageYOffset||document.documentElement.scrollTop,r=t-e;return r>0?Math.round(n/r*100):0}function getVisibleBlockNamesInViewport(){try{const e=(document.querySelector("main")||document).querySelectorAll("[data-block-name]"),t=[],n=0,r=window.innerHeight||document.documentElement.clientHeight||0;return e.forEach(e=>{const o=e.getBoundingClientRect();if(o.bottom>n&&o.top<r){const n=e.getAttribute("data-block-name");n&&t.push(n)}}),[...new Set(t)]}catch(e){return[]}}const handleScrollEvent=throttle(()=>{const e=window.location.href,t=hashString(e),n=getSessionId(),r={event:"page_scroll",userId:getUserId(),session_id:n,page:{url:window.location.href,title:document.title,scrollPercentage:getScrollPercentage(),scrollY:window.pageYOffset||document.documentElement.scrollTop,"component-id":getVisibleBlockNamesInViewport()},from_url:e,item_id:t};window.adobeDataLayer.push(r)},500);function attachScrollListener(){window.addEventListener("scroll",handleScrollEvent,{passive:!0})}function sendTimeSpentBeacon(e){const t=getTimeSpent();if(t>=1&&!timeSpentSent){const n=window.location.href,r=hashString(n),o=getSessionId(),s={event:"time_spent",userId:getUserId(),session_id:o,page:{url:window.location.href,title:document.title,timeSpentSeconds:t,reason:e},from_url:n,item_id:r,timestamp:(new Date).toISOString()};if(navigator.sendBeacon){const e=new Blob([JSON.stringify(s)],{type:"application/json"});navigator.sendBeacon(API_ENDPOINT,e),timeSpentSent=!0}}}function attachTimeSpentListeners(){window.addEventListener("pagehide",e=>{if(timeSpentInterval&&(clearInterval(timeSpentInterval),timeSpentInterval=null),e.persisted||timeSpentSent)console.debug("⏭️ pagehide event: skipping time_spent, persisted:",e.persisted,"timeSpentSent:",timeSpentSent);else{getTimeSpent();pushTimeSpentEvent("navigation")}}),window.addEventListener("beforeunload",e=>{if(!timeSpentSent){getTimeSpent();pushTimeSpentEvent("navigation")}recommendWorker&&workerBlobUrl&&(recommendWorker.terminate(),URL.revokeObjectURL(workerBlobUrl),recommendWorker=null,workerBlobUrl=null)});window.location.href}function hashString(e){let t=0;if(0===e.length)return t.toString();for(let n=0;n<e.length;n++){t=(t<<5)-t+e.charCodeAt(n),t&=t}return Math.abs(t).toString(36)}function getCategoryId(){const e=document.querySelector('meta[name="category"]');return e&&e.getAttribute("content")||null}function getSessionId(){let e=sessionStorage.getItem("session_id");if(e)return e;e=`session_${Date.now()}_${Math.random().toString(36).substring(2,15)}`;try{sessionStorage.setItem("session_id",e)}catch(e){console.warn("sessionStorage not available, session_id will not persist")}return e}function generateUserId(){return`uid_${Date.now()}_${Math.random().toString(36).substring(2,15)}`}function setUserId(e){if(!e||""===e.trim())return;const t=new Date;t.setMonth(t.getMonth()+1),document.cookie=`uid=${e.trim()}; expires=${t.toUTCString()}; path=/`,window.dispatchEvent(new CustomEvent("userIdChanged",{detail:{userId:e.trim()}}))}function getUserId(){const e=document.cookie.split("; ").find(e=>e.startsWith("uid="))?.split("=")[1];if(e)return e;const t=generateUserId(),n=new Date;return n.setMonth(n.getMonth()+1),document.cookie=`uid=${t}; expires=${n.toUTCString()}; path=/`,t}function initializeRealTimeRecommendationsWorker(){try{const e=getUserId(),t=getSessionId();if(!e)return;if(window.realTimeRecommendationsWorker)return;const n=["/blocks/real-time-recommendations/real-time-recommendations-worker.js",`${window.location.origin}/blocks/real-time-recommendations/real-time-recommendations-worker.js`,"./blocks/real-time-recommendations/real-time-recommendations-worker.js"];let r=null;if(n.some(e=>{try{return r=new Worker(e),!0}catch(e){return!1}}),!r)return;if(window.realTimeRecommendationsWorker=r,r.addEventListener("message",e=>{const{type:t,data:n}=e.data;if("storeRecommendations"===t)try{const e="real-time-recommendations";localStorage.setItem(e,JSON.stringify(n))}catch(e){}else if("storeMatchedItems"===t)try{const e="real-time-query_index_matched_items";sessionStorage.setItem(e,JSON.stringify(n))}catch(e){}}),r.onerror=()=>{},!r._scheduleStarted){const n=window.location.origin;r.postMessage({type:"startSchedule",data:{userId:e,sessionId:t,baseUrl:n,interval:6e4}}),r._scheduleStarted=!0}window._realTimeWorkerUserIdListenerAdded||(window.addEventListener("userIdChanged",()=>{window.realTimeRecommendationsWorker&&(window.realTimeRecommendationsWorker.postMessage({type:"stopSchedule"}),window.realTimeRecommendationsWorker.terminate(),window.realTimeRecommendationsWorker=null,initializeRealTimeRecommendationsWorker())}),window._realTimeWorkerUserIdListenerAdded=!0)}catch(e){}}window.adobeDataLayer.push(function(e){e.addEventListener("adobeDataLayer:event",function(e){"cmp:click"!==e.event&&"cmp:click_recom"!==e.event&&"view_item"!==e.event&&"page_view"!==e.event&&"page_scroll"!==e.event&&"time_spent"!==e.event&&"add_to_cart"!==e.event&&"add_to_cart_recom"!==e.event||pushToCustomEndpoint(e)})}),window.setUserId=setUserId;